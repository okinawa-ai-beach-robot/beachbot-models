"""Functions for downloading files from Huggingface Hub."""

from pathlib import Path
from typing import Optional

import numpy as np
import pandas as pd
from beachbot_config import config, logger
from beachbot_models.supported_models import SupportedModels
from beachbot_models.config import load_config_file
from huggingface_hub import ModelCard, ModelCardData, hf_hub_download

BEACHBOT_MODELS = Path(config.BEACHBOT_MODELS)

def get_file(
    filename: str,
    model_type: SupportedModels = SupportedModels.YOLOV5S,
    model_name: Optional[str] = None,
    repo_id: str = "okinawa-ai-beach-robot",
    resolution: int = 640,
    version: Optional[str] = None,  # Defaults to tip of main branch when None
) -> Path:
    """
    Get file from using hf_hub_download and default values unless overridden.

    Args
    -------
        model_type: SupportedModels
        repo_id: str (defaults to okinawa-ai-beach-robot)
        version: str (should be vX, where X is an integer)
        resolution: int within the set {160, 320, 640, 1280}

    Returns
    -------
        file_path: Path

    """
    if model_name is None:
        model_name = f"{model_type.value}_beachbot_{resolution}"

    repo_path = f"{repo_id}/{model_name}"

    file_path = hf_hub_download(
        repo_id=repo_path,
        filename=filename,
        revision=version,
        cache_dir=str(BEACHBOT_MODELS),
    )
    file_path = Path(file_path)
    logger.info(f"Model downloaded to {file_path}")
    return file_path


def get_weights(
    model_type: SupportedModels,
    resolution: int = 640,
    version: Optional[str] = None,
) -> Path:
    """
    Get weights using hf_hub_download and default values unless overridden.

    Args
    -------
        model_type: SupportedModels
        version: str (should be vX, where X is an integer. Defaults to tip of
        main branch when None)
        resolution: int within the set {160, 320, 640, 1280}

    Returns
    -------
        weights_path: Path

    """
    filename: str
    if model_type == SupportedModels.YOLOV5S:
        filename = "weights/best.pt"
    else:
        raise ValueError(
            f"Unknown model_type {model_type}."
            f"Please use one of the SupportedModels."
        )
    weights_path = get_file(
        model_type=model_type,
        version=version,
        resolution=resolution,
        filename=filename,
    )
    return weights_path


def get_base_weights(
    model_type: SupportedModels = SupportedModels.YOLOV5S,
    model_name="yolov5",
    repo_id: str = "ultralytics",
    version=None,
):
    """
    Get base model weights.

    Args
    -------
        model_type: SupportedModels
        version: str (should be vX, where X is an integer. Defaults to tip of
        main branch when None)
        resolution: int within the set {160, 320, 640, 1280}

    Returns
    -------
        weights_path: Path

    """
    filename: str = f"{model_type.value}.pt"
    weights_path = get_file(filename, model_type, model_name, repo_id)
    return weights_path


def generate_results_table(evaluation_csv: Path, markdown_file: Path):
    """
    Generate table using COCO_evaluation from globox.
    Generates markdown table from a CSV file

    Args
    ----
        evaluation_csv: Path to csv file generated by globox COCO_evaluation
        markdown_file: Path to save the markdown table to (typically README.md)
    """
    if not evaluation_csv.exists():
        raise ValueError(f"{evaluation_csv} does not exist")

    # Convert the CSV string to a pandas DataFrame
    data = pd.read_csv(evaluation_csv)

    # Replace 'nan' strings with actual np.nan for better representation
    data.replace("nan", np.nan, inplace=True)

    # Generate Markdown table
    markdown_table = data.to_markdown(index=False)

    # Output the Markdown table
    print(markdown_table)

    # Optionally, write to a Markdown file
    with open(markdown_file, "w") as f:
        f.write(markdown_table)


def create_model_card(
    config_path: Optional[Path] = None,
    save: bool = True,
    **kwargs,
):
    """
    Create a model card using template and defaults from config file
    """
    if config_path is None:
        config_path = Path(config.BEACHBOT_CONFIG / "model_card_config.yaml")

    # Load defaults from config file
    defaults = load_config_file(config_path)

    # Handle 'card_data' separately as it's an object
    defaults["card_data"] = ModelCardData(**defaults["card_data"])

    # Update with any additional keyword arguments provided
    defaults.update(kwargs)

    # Pass the updated values to from_template
    card = ModelCard.from_template(**defaults)

    # Save the card and print
    if save:
        card.save("README.md")
    print(card)
